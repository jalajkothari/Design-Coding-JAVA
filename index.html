        <html><head>
        <title>Design Coding JAVA</title></head><body><p>&nbsp;</p>         <h2>Coding Guidelines</h2><h3><strong>Fundamentals</strong></h3><ol><li>Use java generics wherever possible to enforce templatization.</li><li>Always override toString() method of a POJO class (model/entity/DTO) so that object can be directly used in logging instead of logging objects variables in multiple logger statements.</li><li>Wherever possible use switch statement instead of if/else construct.</li><li>Use enum instead of constant for logical set of values such as status, product code, communication mode etc.</li><li>For a good design, the rule is to be as restrictive as possible when setting the visibility of a method.</li><li>Avoid using System.out.println. Use logger instead.</li><li>If Object.equals is overridden, also override Object hashCode, and vice-versa.</li><li>Prefer returning Empty Collections instead of Null.</li><li>Wherever possible use List interface in method arguments and accessing list implementation.</li><li>There should NOT be any duplicate code</li><li>Do NOT keep any commented / dead / unused code.</li><li>No method should have more than 50 lines of code.</li></ol><h3><strong>Code Formatting/Style</strong></h3><ol><li>Package name should have all letters in lower case.</li><li>For class name, use camel case notation where first letter should be capitalized.</li><li>For variable name, use camel case notation where first letter should be lower case.</li><li>Never use special characters including underscore(_) in class, package and variable name except constant variables (static and final). Use full English descriptors that accurately describe the variable, method or class. For example, use of names like totalSales, currentDate instead of names like x1, y1, or fn.</li><li>Constants, whose values that do not change, are typically implemented as static final fields of classes. They should be represented with full English words, all in uppercase, with underscores between the words like FINAL_VALUE.</li></ol><h3>Exception Handling</h3><ol><li><p>The exception must be translated to relevant business exception and then thrown so that it can be translated to a meaningful message for the user. All the try catch blocks must either throw a valid business exception or must be removed if they are not catching exceptions for any valid scenarios. Logging in catch block and re-throwing same exception should not be done. The empty catch block must be verified if the exception needs to be caught here or it needs to be validated at the caller code i.e. UI or any other interface. In case this is applied to catch Null pointer exception then this should not be done.<br />try{<br />}catch(SQLException sqle){<br /> throw new BusinessException(sqle);<br />}finally{<br />///close any streams or connections or any resources that you might have accessed.<br />}</p></li><li><p>All custom exceptions should extend BaseException and it should be caught and handled in controller based on error code.</p></li><li><p>There must be mapping of error codes with business exception being thrown by business layer. Don't through object of &quot;Exception&quot; class from any layer.</p></li><li>Always correctly wrap the exceptions in custom exceptions so that stack trace is not lost.</li></ol><h3>Logging</h3><ol><li><p>Across the layers, following guidelines will be used to decide on conventions used for choosing appropriate logging level.</p><table class="wrapped confluenceTable"><colgroup><col /><col /></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Logging Level</strong></p></td><td class="confluenceTd"><p><strong>Scenario</strong></p></td></tr><tr><td class="confluenceTd"><p align="left">LOG TRACE</p></td><td class="confluenceTd"><p align="left">Do not use this level in the application, in favor of simple and easier to read code.</p></td></tr><tr><td class="confluenceTd"><p align="left">LOG DEBUG</p></td><td class="confluenceTd"><p align="left">Use this level for logging parameters received, output and dump object information etc.</p><p align="left">Frequency: Use liberally in application.</p></td></tr><tr><td class="confluenceTd"><p align="left">LOG ERROR</p></td><td class="confluenceTd"><p align="left">Use this level whenever there is exception or non-recoverable error in the code. For e.g.</p><ul><li>Database Exception</li><li>Business Exception</li><li>Connection Error</li></ul></td></tr><tr><td class="confluenceTd"><p align="left">LOG WARN</p></td><td class="confluenceTd"><p align="left">Use this level whenever there is non-fatal, recoverable errors. Something is not right, but the process can carry on as before.</p><p align="left">When a developer is not sure if there could be a problem in particular block, he should use warn level. Use warning level in scenarios that occur rarely.</p><p align="left">For e.g.  Database connection unavailability is warning.</p></td></tr><tr><td class="confluenceTd"><p align="left">LOG INFO</p></td><td class="confluenceTd"><p align="left">Used to indicate important milestones achieved.</p><p align="left">Eg. Partner &lt;Partner_Code&gt; , &lt;Partner_Type&gt; onboarded.</p><p align="left">Frequency : Low- medium (only important milestones to  be capture)</p></td></tr></tbody></table><p class="auto-cursor-target"><br /></p></li></ol><h2>Design Guidelines</h2><h3><strong>Fundamentals</strong></h3><ol><li><strong>Duplicate Code</strong>: Wherever possible reuse the existing logic instead of writing new flow. If same code can't be reused, take your seniors help to refactor.</li><li><strong>Design Rule:</strong> Following design rules should be followed.</li></ol><table class="wrapped confluenceTable"><colgroup><col /><col /></colgroup><tbody><tr><td class="confluenceTd"><p><strong>Rule</strong></p></td><td class="confluenceTd"><p><strong>Description</strong></p></td></tr><tr><td class="confluenceTd"><p>Single responsibility principle</p></td><td class="confluenceTd"><p>A class should have one and only one task/responsibility. If class is performing more than one task, it leads to confusion and will be difficult to understand, reuse, refactor and perform unit testing.</p></td></tr><tr><td class="confluenceTd"><p>Open/closed principle</p></td><td class="confluenceTd"><p>The developers should focus more on extending the software entities rather than modifying them.</p></td></tr><tr><td class="confluenceTd"><p>Liskov substitution principle</p></td><td class="confluenceTd"><p>It should be possible to substitute the derived class with base class.</p></td></tr><tr><td class="confluenceTd"><p>Interface segregation principle</p></td><td class="confluenceTd"><p>It’s like Single Responsibility Principle but applicable to interfaces. Each interface should be responsible for a specific task. The developers should need to implement methods which he/she doesn’t need.</p></td></tr><tr><td class="confluenceTd"><p>Dependency inversion principle</p></td><td class="confluenceTd"><p>Depend upon Abstractions- but not on concretions. This means that each module should be separated from other using an abstract layer which binds them together</p></td></tr></tbody></table><p><br /></p><h3>Data Access / BO</h3><ol><li>For any new development, we should use Spring Data instead of DAO (with Hibernate) to define repository and access the data</li><li>Domain classes and hbm files should be common for both portal and oasys. These should be part of OAServices.</li><li><strong>**</strong>Entity object should not be passed beyond BO layer. These should be transformed into DTO before returning to Facade layer.</li><li><strong>**</strong>Domain Relationship should be used wherever applicable.</li><li>There should be DAO specific to entity. One DAO shouldn’t have reference to other DAOs. For new implementation use spring DAO where one repository should deal with one entity.</li><li>Return type of method will decide which DAO class to have the method. For e.g. below method should be in CategoryDAOImpl as the return type is 'Category' list.<ol><li>public List&lt;Category&gt; getAllCategory() throws PlanException;</li></ol></li><li>A BO class can refer to multiple DAO to get the information for multiple entities.</li><li>A BO or facade can refer multiple BOs depending on business scenario.</li><li>If business logic need to be completed in a single transaction only then a BO can refer another BO but if it is read only data then Façade can have multiple BO references.</li><li>Transaction management should be done at BO layer.</li><li><p>While writing queries, always use bind variables. Without bind variable, queries can't be cached and hence lead to performance and security issues.</p></li><li><p>Don't mix bean configuration via xml and annotation. Use xml based bean mapping and dependency injection. Don't use @autowired annotation as<span style="color: rgb(38,38,38);"> it’s hard to find <span style="color: rgb(38,38,38);">dependency </span>using autowire attribute of bean, if there are <span style="color: rgb(38,38,38);">lot of dependency beans in a project.</span></span></p></li><li><p>Enable Lazy Loading for the collections that is not required in resultset otherwise use eager loading.</p></li></ol><h3><strong>API</strong></h3><ol><li>Going forward we will maintain only ONE version of API which can be accessed by internal and external systems. Hence we should not have separate API for partner and CRM system</li><li>All API should be in JAX-RS and use JSON format for any data exchange. We should NOT use SOAP or XML format anymore</li></ol><h3><strong>Web</strong></h3><ol><li>There should not be any redirection in customer facing flow.</li><li><p>Big patches of java code in JSP should be avoided and is should be rather shifted to some Wrapper/Helper/Bean class which should be used together with every JSP. Number of method calls from JSP should be reduced as much as possible to achieve maximum efficiency and the least response time. In brief JSP should be designed as light as possible.</p></li><li><p>Storing heavy objects in the Session can lead to slowing of the running of the JSP page so such case should be avoided.</p></li><li>For new implementation, jsps should be avoided. Instead use angular js with rest web services.</li></ol><h3>Validation</h3><ol><li>We should use in-built validators from Apache Validator framework. If required we can add our custom validators that implements the interface from Apache Validator.</li></ol><h3>Caching</h3><ol><li>Master data which is not changing frequently, should be cached for longer duration. There should be provision to define cache refresh interval entity wise.</li><li>For a given entity it should have single cache. Creating multiple cache of same entity for different purpose will defeat the use of cache.</li></ol><h3>Performance</h3><ol><li>There should not be any inline/synchronous http call. For e.g. calling Experian service to send an email in synchronous call.</li><li>Execution time of any API call should be between 200 - 500 milliseconds. If there is any exception then it needs to discussed and approved by technical architect.</li><li><p>Any DB finders/updaters in the loop impact the performance of the code and must be taken out of the loop. Bulk insertions or updations can help increase the performance. When applying the finders inside the loop, the query can be revisited to find all the objects in one DB call.</p></li><li><p>Avoid excessive object creation. Objects creation which would be same for all the iterations should be created outside the loop at the most once and that object should be re-used inside the loop e.g. Strings, StringBuffers, StringBuilders, Date. Objects that are created to persist them in the DB should be taken out of the loop such that the objects are created in bulk/batch. Even String concatenations inside the loop affect the performance. Attention must be given to minimize the concatenation of strings and use StringBuilder instead.</p></li></ol>
        <p>&nbsp;</p>
    </body>
</html>
